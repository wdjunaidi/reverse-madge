const fs = require('fs');
const R = require('ramda');

let stringify = R.curry(JSON.stringify)(R.__, null, 2);

if (process.argv[2]) {
  fs.readFile(process.argv[2], 'utf-8', (err, data) => {
    if (err) {
      return console.error(err);
    }

    let dependsOn = JSON.parse(data);
    let dependedBy = reverseDependencies(dependsOn);
    let result = R.sort(comparator, combine(dependsOn, dependedBy));
    console.log(stringify(result));
  });
}

let comparator = R.comparator((a, b) => {
    if (a.dependedBy.size === b.dependedBy.size) {
        return a.dependsOn.size > b.dependsOn.size;
    }
    return a.dependedBy.size > b.dependedBy.size;
});

function combine(dependsOn, dependedBy) {
  let uniqueKeys = R.union(R.keys(dependsOn), R.keys(dependedBy));
  let extractCoDepByKey = R.curry(createCoDep)(dependsOn, dependedBy);

  return R.map(extractCoDepByKey, uniqueKeys);
}

function createCoDep(on, by, key) {
  let depBy = by[key] || [];
  let depOn = on[key] || []; 
  return {
    target: key,
    dependedBy: {
      size: depBy.length,
      list: depBy
    },
    dependsOn: {
      size: depOn.length,
      list: depOn
    }
  };
}

/**
 * Reverse the data format generated by pahen/madge. 
 * The input data in format of
 * <pre>
 * {
 *    "modA": ["dependency1", "dependency2"],
 *    "modB": ["dependency1", "depepdency3"]
 * }
 * </pre>
 * 
 * And reverse the relatinship from dependent-on to depended-by.
 * <pre>
 * {
 *    "dependency1": ["modA", "modB"],
 *    "dependency2": ["modA"],
 *    "dependency3": ["modB"]
 * }
 * </pre>
 */
function reverseDependencies(data) {
  let keys = R.keys(data);

  return R.reduce((acc, key) => {
    let dependencies = data[key];
    if (dependencies && dependencies.length > 0) {
      R.forEach((dependency) => {
        acc[dependency] = acc[dependency] || [];
        acc[dependency].push(key);
      }, dependencies);
    }
    return acc;
  }, {}, keys);
}
